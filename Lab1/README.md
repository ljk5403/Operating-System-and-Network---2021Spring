# 实验一：进程调度
作者 [Alexhaoge](https://github.com/Alexhaoge)
## 运行说明
1. Prerequisite: g++, make
2. 运行`make`命令进行编译
3. 运行`make test`，会随机生成10个进程PCB，然后进行调度，运行结果在`result.log`中
## 部分设计细节
1. 随机生成PCB：为增大出现“需要调度”的情况的可能性，随机范围如下，优先级0-9，到达时间0-9，运行时间1-10
2. 使用优先队列（大根堆）维护就绪队列，这样获取优先级最高的进程会快一些，但是对于实验时需要打印所有进程信息的效率不高
## 附录：题目描述
**设计一个有 N个进程的进程调度程序**
进程调度算法：采用最高优先数优先的调度算法（即把处理机分配给优先数最高的进程）和先来先服务算法。  
每个进程有一个进程控制块（ PCB）表示。进程控制块可以包含如下信息：进程名、优先数、到达时间、需要运行时间、已用CPU时间、进程状态等等。  
进程的优先数及需要的运行时间可以事先人为地指定（也可以由随机数产生）。进程的到达时间为进程输入的时间。  
进程的运行时间以时间片为单位进行计算。  
每个进程的状态可以是就绪 W（Wait）、运行R（Run）、或完成F（Finish）三种状态之一。  
就绪进程获得 CPU后都只能运行一个时间片。用已占用CPU时间加1来表示。  
如果运行一个时间片后，进程的已占用 CPU时间已达到所需要的运行时间，则撤消该进程，如果运行一个时间片后进程的已占用CPU时间还未达所需要的运行时间，也就是进程还需要继续运行，此时应将进程的优先数减1（即降低一级），然后把它插入就绪队列等待CPU。  
每进行一次调度程序都打印一次运行进程、就绪队列、以及各个进程的 PCB，以便进行检查。 
重复以上过程，直到所要进程都完成为止。
